# Convention-based detection of PRs and tickets

Date: 2026-03-01

## Context

Two recurring questions when managing multiple workspaces: "What ticket is this workspace for?" and "Which PR merged this branch?" Arborist already detects merge status (via ancestor checks and patch-id squash detection from [0016](0016-patch-id-rebased-commit-detection.md)) but discards the matching commit, losing the PR number embedded in its subject. And while branch names often encode ticket keys (e.g. `ester-208-fix-login`), arb doesn't extract or display them.

Both are read-only overview enrichments. The question is whether to use API calls (GitHub, Jira, Linear) or local git data.

## Options

### A: API-based detection
Query GitHub/GitLab API for PR data and Jira/Linear API for ticket details.
- **Pros:** Authoritative data — real PR titles, ticket status, URLs.
- **Cons:** Requires authentication tokens, network access, vendor-specific code. Adds latency to overview commands. Configuration burden for each provider.

### B: Convention-based detection from local git data
Extract PR numbers from merge/squash commit subjects (machine-generated by GitHub/Azure DevOps) and from the branch tip commit itself as a last-resort fallback. Extract ticket keys from branch names and commit messages via regex.
- **Pros:** Zero configuration, no network traffic, no vendor lock-in. Works offline. Leverages conventions already followed by most teams.
- **Cons:** Heuristic — can't detect PR numbers from fast-forward merges or GitLab MRs. Can't construct ticket URLs without org-specific config.

### C: Hybrid — local detection with optional API enrichment
Start with convention-based detection, add optional API integration later.
- **Pros:** Immediate value with zero config. API enrichment available for teams that want it.
- **Cons:** More complex long-term, but option B is a clean subset.

## Decision

Option B now, with option C as a future path. Pure convention-based detection from local git data — no network traffic, no stored metadata, no user configuration.

## Reasoning

The core value is answering "what ticket?" and "which PR?" in overview commands. For GitHub (the dominant provider), merge and squash commit subjects reliably contain `#N` — this is machine-generated, not typed by the developer. Branch-name ticket keys are equally reliable. These cover the vast majority of real-world use cases with zero configuration.

All detected values use "detected" in field names (`detectedPr`, `detectedTicket`) and documentation to communicate that they are heuristic, not authoritative. This follows the principle of being transparent about confidence levels.

API integration is deferred until auto-detection proves insufficient. If added later, it would enrich existing fields rather than replace the detection pipeline.

## Consequences

- PR numbers are shown in `arb status` SHARE column for merged branches (e.g. `merged (#123), gone`) and in `--verbose` detail and `--json` output.
- Ticket keys are shown as a conditional TICKET column in `arb list` and in `--json` output for both `list` and `status`.
- PR URLs are constructed from remote URL parsing for GitHub, GitLab, Bitbucket, and Azure DevOps. Unknown hosts get the PR number without a URL.
- Ticket URLs cannot be constructed without org-specific configuration — deferred.
- Fast-forward merges and GitLab MRs produce no detectable PR number from git data alone.
- The `detectedPr` and `detectedTicket` field names set the expectation that these are heuristic, making it safe to add authoritative API-based fields alongside them later without a breaking change.
- Ticket detection blocks `PR` and `MR` prefixes — these are universally reserved for Pull Request / Merge Request in developer tooling and cannot be real project keys. A branch named `svc-riskman-pr-74` does not produce a false `PR-74` ticket. The blocklist is intentionally minimal (2 entries); other 2-letter prefixes like `CI`, `QA`, `RC` are not blocked because they could be legitimate project keys.
